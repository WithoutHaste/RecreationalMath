using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using WithoutHaste.Sequences.Tools;

namespace WithoutHaste.Sequences
{
	/// <summary>
	/// A list or category of integer numbers, generated by some rule.
	/// </summary>
	public abstract class Sequence
	{
		/// <summary>
		/// The maximum number that can be in the sequence.
		/// </summary>
		public int Max { get; protected set; }
		/// <summary>
		/// Returns the full list of numbers, ordered least to greatest.
		/// </summary>
		public List<int> Numbers { get; protected set; }
		/// <summary>
		/// Returns element at 0-based index.
		/// </summary>
		/// <remarks>
		/// Does not protect against out of range errors.
		/// </remarks>
		public int this[int index] { get { return Numbers[index]; } }

		/// <summary>
		/// Set to true if loading pre-generated data was able to confirm that all elements up the Max were loaded.
		/// </summary>
		private bool loadReachedMax = false;

		/// <summary>
		/// List of numbers from other sources to test against.
		/// </summary>
		internal static int[] TestNumbers;

		public Sequence(int max)
		{
			Numbers = new List<int>();
			Max = max;
			Initialize();
			Load();
			if(loadReachedMax)
				return;
			Generate();
		}

		/// <summary>
		/// Initialize tracking and generator.
		/// Occurs before Load and Generate.
		/// </summary>
		protected virtual void Initialize()
		{
			//no statement
		}

		/// <summary>
		/// Generates the full list of numbers.
		/// </summary>
		protected abstract void Generate();

		/// <summary>
		/// Returns an ordered list of the numbers that appear in both sequences.
		/// </summary>
		/// <exception cref='Exception'>Both sequences must have the same Max value.</exception>
		public int[] Intersect(Sequence other)
		{
			if(this.Max != other.Max)
				throw new Exception("Both sequences must have the same Max value.");
			return this.Numbers.Intersect(other.Numbers).OrderBy(x => x).ToArray();
		}

		/// <summary>
		/// Folder to contain all files related to this sequence.
		/// </summary>
		protected abstract string GetSaveToFolder();

		/// <summary>
		/// Load pre-generated data from file(s).
		/// Assumes files contain every element in the sequence in the file's range.
		/// </summary>
		private void Load()
		{
			string path = Path.Combine(Settings.SaveToDirectory, GetSaveToFolder());
			if(!Directory.Exists(path))
				return;
			string[] filenames = Directory.GetFiles(path).Select(f => Path.GetFileName(f)).ToArray();
			Array.Sort(filenames, new StartsWithNumberComparer());
			foreach(string filename in filenames)
			{
				using(BinaryReader reader = new BinaryReader(File.Open(Path.Combine(path, filename), FileMode.Open)))
				{
					while(reader.BaseStream.Position != reader.BaseStream.Length)
					{
						int number = reader.ReadInt32();
						if(number > Max)
						{
							loadReachedMax = true;
							break;
						}
						Load_AddNumber(number);
					}
				}
			}
		}

		/// <summary>
		/// How to apply a pre-loaded number to the collection.
		/// </summary>
		protected virtual void Load_AddNumber(int number)
		{
			Numbers.Add(number);
		}

		/// <summary>
		/// Save sequence to file(s).
		/// </summary>
		/// <remarks>
		/// Files are saved in binary format to save space.
		/// It is one Int32 after another, with nothing between them.
		/// Therefore, the largest sequence element that can be saved is Int32.MaxValue.
		/// </remarks>
		/// <remarks>
		/// Does not remove old files.
		/// </remarks>
		public void Save()
		{
			string path = Path.Combine(Settings.SaveToDirectory, GetSaveToFolder());
			Directory.CreateDirectory(path);

			int range = Settings.SaveRangePerFile;
			int min = 1;
			List<List<int>> segments = BreakSequenceIntoSegments(range);
			foreach(List<int> segment in segments)
			{
				string filename = String.Format("{0}to{1}.{2}", min, min + range - 1, Settings.IntegerFileExtension);
				using(BinaryWriter writer = new BinaryWriter(File.Open(Path.Combine(path, filename), FileMode.Create))) //create or overwrite
				{
					foreach(int number in segment)
					{
						writer.Write(number);
					}
				}
				string textFilename = String.Format("{0}to{1}.txt", min, min + range - 1);
				using(StreamWriter writer = new StreamWriter(Path.Combine(path, textFilename)))
				{
					foreach(int number in segment)
					{
						writer.WriteLine(number);
					}
				}
				min += range;
			}
		}

		/// <summary>
		/// Breaks sequence into segments to save to files.
		/// </summary>
		private List<List<int>> BreakSequenceIntoSegments(int range)
		{
			List<List<int>> segments = new List<List<int>>();
			List<int> nextSegment = new List<int>();
			int segmentMax = range;
			for(int i = 0; i < this.Numbers.Count; i++)
			{
				if(this.Numbers[i] > segmentMax)
				{
					segments.Add(nextSegment);
					nextSegment = new List<int>();
					segmentMax += range;
				}
				nextSegment.Add(this.Numbers[i]);
			}
			segments.Add(nextSegment);
			return segments;
		}
	}
}
